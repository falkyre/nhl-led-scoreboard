<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NHL Scoreboard Logo Editor</title>
    <style>
        @font-face {
            font-family: 'PixelFont';
            src: url('/assets/fonts/04B_24__.TTF') format('truetype');
        }

        @font-face {
            font-family: 'ScoreFont';
            src: url('/assets/fonts/score_large.otf') format('opentype');
        }

        :root {
            --bg-color: #1a1a1a;
            --panel-bg: #2d2d2d;
            --text-color: #e0e0e0;
            --accent: #007acc;
            --grid-color: #333;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            gap: 20px;
            height: 100vh;
            box-sizing: border-box;
        }

        .controls {
            flex: 0 0 350px;
            background: var(--panel-bg);
            padding: 20px;
            border-radius: 8px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .workspace {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
            overflow-y: auto;
        }

        .editor-container {
            position: relative;
            background-color: #000;
            border: 4px solid #444;
            background-image: radial-gradient(circle, #222 30%, transparent 35%);
            background-size: 10px 10px;
            overflow: hidden;
            flex: 0 0 auto;
            transition: width 0.3s, height 0.3s;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .logo-obj {
            position: absolute;
            /* Origin set dynamically in JS */
            left: 0;
            top: 0;
            z-index: 10;
            image-rendering: pixelated;
        }

        /* UPDATED: Box Shadow instead of Border to prevent layout shifts */
        .logo-editable {
            cursor: move;
            user-select: none;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.3);
            /* Subtle outline */
        }

        .logo-editable:hover {
            box-shadow: 0 0 0 1px #00ff00;
        }

        .logo-editable.resizing {
            cursor: ns-resize !important;
            box-shadow: 0 0 0 1px #00ccff;
        }

        .logo-static {
            cursor: default;
            pointer-events: none;
            opacity: 0.8;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.1);
        }

        .gradient-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 15;
        }

        .game-info-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            pointer-events: none;
            z-index: 20;
            text-shadow: 1px 1px 0px #000;
        }

        .info-line {
            color: #ffffff;
            line-height: 1;
            text-align: center;
            white-space: nowrap;
        }

        .anchor-marker {
            position: absolute;
            width: 6px;
            height: 6px;
            background: rgba(255, 0, 0, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 25;
            box-shadow: 0 0 4px #ff0000;
        }

        /* Controls CSS */
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.9em;
        }

        select,
        input[type="number"],
        input[type="text"] {
            width: 100%;
            padding: 8px;
            background: #444;
            border: 1px solid #555;
            color: #fff;
            border-radius: 4px;
            margin-bottom: 5px;
            box-sizing: border-box;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #333;
            padding: 10px;
            border-radius: 4px;
        }

        input[type="checkbox"] {
            width: auto;
            transform: scale(1.2);
        }

        .row {
            display: flex;
            gap: 10px;
        }

        .row>div {
            flex: 1;
        }

        button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        button:hover {
            filter: brightness(1.1);
        }

        button.secondary {
            background: #555;
        }

        button.danger {
            background: #cc3300;
        }

        .emulator-header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex: 0 0 auto;
        }

        .emu-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .emu-controls button {
            padding: 5px 15px;
            font-size: 0.9em;
        }

        .emulator-wrapper {
            background: #222;
            border-radius: 8px;
            border: 1px solid #444;
            overflow: auto;
            max-height: 50vh;
            padding: 10px;
            transition: max-height 0.3s, padding 0.3s, opacity 0.3s;
            opacity: 1;
            display: block;
            width: calc(100% - 20px);
            box-sizing: content-box;
        }

        .emulator-wrapper.collapsed {
            max-height: 0;
            padding: 0;
            border: none;
            opacity: 0;
            overflow: hidden;
        }

        #emuInner {
            position: relative;
            background: #000;
            margin: 0 auto;
            flex: 0 0 auto;
        }

        iframe {
            width: 100%;
            height: 100%;
            border: none;
            display: block;
        }

        .emu-loader {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            z-index: 100;
            display: none;
        }

        .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #555;
            margin-right: 5px;
        }

        .status-dot.running {
            background: #00ff00;
            box-shadow: 0 0 5px #00ff00;
        }

        h2,
        h3 {
            margin-top: 0;
        }

        .status {
            font-size: 0.8em;
            color: #888;
            text-align: right;
            min-height: 1.2em;
        }

        /* Calendar Highlights */
        /* Use pseudo-elements for underlines to avoid border-radius making them curved */
        .flatpickr-day.home-game,
        .flatpickr-day.away-game {
            position: relative;
        }

        .flatpickr-day.home-game::after,
        .flatpickr-day.away-game::after {
            content: "";
            position: absolute;
            bottom: 3px;
            left: 15%;
            width: 70%;
            height: 2px;
            border-radius: 0;
        }

        .flatpickr-day.home-game::after {
            background-color: #00ff00;
        }

        .flatpickr-day.away-game::after {
            background-color: #00ccff;
        }

        /* Remove old border approach if it conflicts and ensure hover states don't break it */
        .flatpickr-day.home-game:hover,
        .flatpickr-day.away-game:hover {
            background: #333;
        }

        .calendar-legend {
            display: flex;
            gap: 15px;
            font-size: 0.8em;
            margin-top: 0;
            color: #aaa;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <link rel="stylesheet" type="text/css" href="https://npmcdn.com/flatpickr/dist/themes/dark.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
</head>

<body>

    <div class="controls">
        <h2>Configuration</h2>

        <div>
            <label>Matrix Size</label>
            <select id="sizeSelect" onchange="loadMatrixSize(true)">
                <option value="64x32">64x32</option>
                <option value="128x64">128x64</option>
                <option value="128x32">128x32</option>
            </select>
        </div>



        <hr style="border-color:#444; width:100%">
        <div>
            <label style="color:var(--accent)">Main Team (Editing)</label>
            <select id="teamSelect" onchange="handleTeamChange()"></select>
            <div style="margin-top:5px; display:flex; gap:5px;">
                <button id="btnUploadFile" onclick="triggerAltUpload()"
                    style="font-size:0.8em; padding:4px 8px; flex:1;" title="Upload alternate logo">Upload
                    File</button>
                <button id="btnUploadUrl" onclick="triggerAltUrlUpload()"
                    style="font-size:0.8em; padding:4px 8px; flex:1;" title="Upload alternate logo">Upload
                    from URL</button>
                <input type="file" id="altUploadInput" accept="image/*" style="display:none">
            </div>
            <!-- COLOR EDITING -->
            <div style="margin-top:10px; background:#222; padding:8px; border-radius:4px; border:1px solid #333;">
                <label style="font-size:0.8em; color:#aaa; margin-bottom:5px;">Team Colors</label>
                <div class="row" style="margin-bottom:5px;">
                    <div style="display:flex; align-items:center; gap:5px; flex:1;">
                        <input type="color" id="colPrimary"
                            style="width:30px; height:30px; padding:0; border:none; cursor:pointer;"
                            title="Primary Color">
                        <span style="font-size:0.7em; color:#888;">Primary</span>
                    </div>
                    <div style="display:flex; align-items:center; gap:5px; flex:1;">
                        <input type="color" id="colText"
                            style="width:30px; height:30px; padding:0; border:none; cursor:pointer;" title="Text Color">
                        <span style="font-size:0.7em; color:#888;">Text</span>
                    </div>
                </div>
                <button onclick="saveColors()" style="width:100%; font-size:0.8em; padding:4px;">Save Colors</button>
            </div>
        </div>
        <div class="row">
            <div>
                <label>Main Stance</label>
                <select id="stanceSelect" onchange="updateUI()">
                    <option value="away">Away (Left)</option>
                    <option value="home" selected>Home (Right)</option>
                </select>
            </div>
        </div>
        <div style="margin-top:15px;">
            <label style="color:#aaa">Opponent (Visual Only)</label>
            <select id="team2Select" onchange="updateUI()"></select>
        </div>
        <div class="checkbox-row" style="margin-top: 15px;">
            <input type="checkbox" id="showGradient" checked onchange="toggleGradient()">
            <label for="showGradient" style="margin:0; font-weight:normal;">Show Gradient Layer</label>
        </div>

        <hr style="border-color:#444; width:100%">

        <h3>Adjustments <span id="adjustmentsFile"
                style="font-size:0.7em; font-weight:bold; color:#fff; margin-left:5px;"></span></h3>
        <p style="font-size:0.8em; color:#888; margin-top:-10px;"><b>Scroll</b> over logo to Zoom, or <b>Shift+Drag</b>
        </p>

        <div class="row">
            <div>
                <label>Offset X</label>
                <input type="number" id="posX" value="0" oninput="updateLogoFromInput()">
            </div>
            <div>
                <label>Offset Y</label>
                <input type="number" id="posY" value="0" oninput="updateLogoFromInput()">
            </div>
        </div>

        <div class="row" style="margin-bottom: 15px;">
            <div>
                <label style="color:#888; font-size:0.8em;">Actual X (on Panel)</label>
                <input type="text" id="absX" readonly
                    style="color:#aaa; background:#222; border-color:#333; cursor:default;">
            </div>
            <div>
                <label style="color:#888; font-size:0.8em;">Actual Y (on Panel)</label>
                <input type="text" id="absY" readonly
                    style="color:#aaa; background:#222; border-color:#333; cursor:default;">
            </div>
        </div>

        <div class="row">
            <div>
                <label>Zoom (%)</label>
                <input type="number" id="zoom" value="100" oninput="updateLogoFromInput()">
            </div>
            <div>
                <label>Rotate (deg)</label>
                <input type="number" id="rotate" value="0" oninput="updateLogoFromInput()">
            </div>
        </div>
        <div class="row" style="margin-top:10px;">
            <button class="secondary" onclick="toggleFlip()">Flip Horizontal</button>
            <button class="secondary" onclick="resetDefaults()">Reset</button>
        </div>
        <div style="margin-top: auto;">
            <button onclick="saveConfig()" style="width:100%">SAVE CHANGES</button>
            <div id="statusMsg" class="status"></div>
        </div>
    </div>

    <div class="workspace">
        <div style="width:100%; display:flex; justify-content:space-between; align-items:center;">
            <h3>Visual Editor <span id="resDisplay" style="font-weight:normal; font-size:0.8em; color:#888;"></span>
            </h3>
        </div>

        <div id="canvasContainer" class="editor-container">
            <div
                style="position:absolute; left:50%; top:0; bottom:0; border-left:1px dashed #444; pointer-events:none;">
            </div>
            <div id="gameInfoOverlay" class="game-info-overlay">
                <div class="info-line" style="font-family: 'PixelFont'; margin-top: 0;">3rd</div>
                <div class="info-line" style="font-family: 'PixelFont';">12:34</div>
                <div class="info-line" style="font-family: 'ScoreFont'; margin-top: 0;">3-2</div>
            </div>
            <img id="gradientImg" class="gradient-layer" src="" alt="Gradient" draggable="false">
            <div id="anchorMarker" class="anchor-marker"></div>
            <img id="logoImg" class="logo-obj logo-editable" src="" alt="Main Logo" draggable="false">
            <img id="logoImg2" class="logo-obj logo-static" src="" alt="Opponent Logo" draggable="false"
                style="display:none;">
        </div>

        <div class="emulator-header">
            <h3>
                <span id="emuStatusDot" class="status-dot"></span>
                Emulator
                <span style="font-size:0.8em; color:#888;">(localhost:{{ emulator_port }})</span>
            </h3>

            <!-- Emulator Mode Selection -->
            <div>
                <select id="emuMode" onchange="toggleEmulatorMode()"
                    style="padding:4px; width:auto; background:#333; color:#fff; border:1px solid #555;">
                    <option value="live">Live</option>
                    <option value="simulator">Simulator</option>
                </select>
            </div>

            <div class="emu-controls">
                <button onclick="launchEmulator('iframe')" style="background:#28a745;">Launch</button>
                <button onclick="launchEmulator('window')" style="background:#17a2b8;">Launch New Window</button>
                <button onclick="stopEmulator()" class="danger">Stop</button>
                <button id="btnCollapse" class="secondary" onclick="toggleEmulatorCollapse()"
                    style="display:none;">Collapse</button>
            </div>
        </div>

        <!-- Simulator Options Panel -->
        <div id="simOptions"
            style="display:none; background:#222; padding:10px; border-bottom:1px solid #444; gap:10px; align-items:center; flex-wrap:wrap;">

            <div class="calendar-legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: transparent; border-bottom: 2px solid #00ff00;"></div>
                    <span>Home Game</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: transparent; border-bottom: 2px solid #00ccff;"></div>
                    <span>Away Game</span>
                </div>
            </div>

            <div style="flex: 1 1 auto;">
                <label style="font-size:0.8em; color:#aaa; margin-bottom:2px;">Game Date</label>
                <input type="text" id="simDate" style="width:100%; padding:4px;" placeholder="Select Date...">
            </div>
            <div style="flex: 0 0 80px;">
                <label style="font-size:0.8em; color:#aaa; margin-bottom:2px;">Speed x</label>
                <input type="number" id="simSpeed" value="1.0" step="0.1" style="width:100%; padding:4px;">
            </div>
            <div style="display:flex; align-items:center; gap:5px; margin-top:15px;">
                <input type="checkbox" id="simStopAtEnd" style="transform:scale(1.1);">
                <label for="simStopAtEnd" style="font-size:0.8em; color:#aaa; margin-bottom:0; font-weight:normal;">Stop
                    at End</label>
            </div>
        </div>

        <div id="emuWrapper" class="emulator-wrapper collapsed">
            <div id="emuInner">
                <div id="emuLoader" class="emu-loader">Loading...</div>
                <iframe id="emuFrame" src="about:blank" title="Scoreboard Emulator"></iframe>
            </div>
        </div>
    </div>

    <script>
        let currentConfig = {};
        let layoutConfig = {};
        let currentFileName = "";
        let matrixW = 64;
        let matrixH = 32;
        const EDITOR_SCALE = 10;
        const EMU_SCALE = {{ emulator_pixel_size }};
        const STANDARD_TEAMS = {{ teams | tojson }};

        let opponentConfig = null;
        let emulatorRunning = false;

        document.addEventListener('DOMContentLoaded', () => {
            // Restore state BEFORE verifying status
            loadState();
            checkEmulatorStatus(true);

            setupDrag();

            // Add listeners for saving state
            document.getElementById('simSpeed').addEventListener('change', saveState);
            document.getElementById('simStopAtEnd').addEventListener('change', saveState);

            document.getElementById('altUploadInput').addEventListener('change', handleAltUpload);
        });

        function triggerAltUpload() {
            document.getElementById('altUploadInput').click();
        }

        function triggerAltUrlUpload() {
            const team = document.getElementById('teamSelect').value;
            if (!team) {
                alert("Please select a team first.");
                return;
            }
            const url = prompt("Enter Image URL:");
            if (!url) return;

            uploadAltData(team, null, url);
        }

        function handleAltUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const team = document.getElementById('teamSelect').value;
            if (!team) {
                alert("Please select a team first.");
                return;
            }

            uploadAltData(team, file, null);
            event.target.value = ''; // Reset
        }

        function uploadAltData(team, file, url) {
            const createHires = confirm("Do you also want to generate this logo for High Res (128x64) displays?");

            // Ensure we use the clean team name (no |alt) for backend
            const cleanTeam = team.includes('|') ? team.split('|')[0] : team;

            const formData = new FormData();
            formData.append('team', cleanTeam);
            formData.append('create_hires', createHires);
            if (file) {
                formData.append('file', file);
            } else if (url) {
                formData.append('url', url);
            }

            fetch('/api/upload_alt', {
                method: 'POST',
                body: formData
            })
                .then(r => r.json())
                .then(data => {
                    if (data.status === 'success') {
                        alert("Upload successful!");

                        // The backend should have updated the config to include 'alt' for this team.
                        // We need to reload the config to see it in the list.
                        // We also want to auto-select it.
                        let targetTeam = team;
                        if (!team.includes('|alt')) {
                            targetTeam = team + '|alt';
                        }

                        // Set global restore request (handled in loadConfig callback)
                        window.restoreTeam = targetTeam;

                        loadConfig();

                    } else {
                        alert("Upload failed: " + data.message);
                    }
                })
                .catch(err => {
                    console.error("Upload error", err);
                    alert("Upload failed: " + err);
                });
        }

        // ... (skip down to loadMatrixSize) ...

        function loadMatrixSize(userTriggered = false) {
            const sizeStr = document.getElementById('sizeSelect').value;
            // ... existing sizing logic ... 

            // ... (fetch logic) ...
            fetch(`/api/config/layout_${sizeStr}.json`)
                .then(r => r.json())
                .then(layoutData => {
                    layoutConfig = layoutData;
                    const expectedFile = `logos_${sizeStr}.json`;
                    loadConfig(expectedFile);
                })
                .catch(err => {
                    console.error("Failed to load layout config", err);
                    layoutConfig = {};
                    loadConfig(`logos_${sizeStr}.json`); // Fallback
                });

            if (userTriggered) saveState();

            if (userTriggered && emulatorRunning) {
                if (confirm(`Matrix size changed to ${sizeStr}. Restart the emulator with this resolution?`)) {
                    launchEmulator();
                }
            }
        }

        function loadConfig(specificFilename = null) {
            const sizeStr = document.getElementById('sizeSelect').value;
            const filename = specificFilename || `logos_${sizeStr}.json`;

            currentFileName = filename;
            if (!specificFilename) saveState(); // Save on manual change

            document.getElementById('adjustmentsFile').innerText = `(${filename})`;
            fetch('/api/config/' + filename + '?t=' + new Date().getTime())
                .then(r => r.json())
                .then(data => {
                    currentConfig = data;
                    refreshTeamList();

                    // After refreshing team list, restore team/stance if pending
                    if (window.restoreTeam) {
                        const sel = document.getElementById('teamSelect');
                        // verify exists
                        if ([...sel.options].some(o => o.value === window.restoreTeam)) {
                            sel.value = window.restoreTeam;
                        }
                        window.restoreTeam = null;

                        // If we restored team, we might want to trigger opponent update if in sim mode with date set
                        // but let's just let updateUI handle visual
                    }

                    if (window.restoreStance) {
                        document.getElementById('stanceSelect').value = window.restoreStance;
                        window.restoreStance = null;
                    }

                    loadColors(); // Load colors AFTER restoring selection
                    updateUI();
                })
                .catch(err => console.error("Config load failed", err));
        }

        // --- COLOR LOGIC ---

        function componentToHex(c) {
            var hex = c.toString(16);
            return hex.length == 1 ? "0" + hex : hex;
        }

        function rgbToHex(r, g, b) {
            return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
        }

        function hexToRgb(hex) {
            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function loadColors() {
            const team = document.getElementById('teamSelect').value;
            if (!team) return;

            fetch(`/api/colors?team=${encodeURIComponent(team)}`)
                .then(r => r.json())
                .then(c => {
                    if (c.error) {
                        console.error("Color load error", c.error);
                        return;
                    }
                    if (c.primary) {
                        const hex = rgbToHex(c.primary.r, c.primary.g, c.primary.b);
                        document.getElementById('colPrimary').value = hex;
                    }
                    if (c.text) {
                        const hex = rgbToHex(c.text.r, c.text.g, c.text.b);
                        document.getElementById('colText').value = hex;
                    }
                })
                .catch(err => console.error(err));
        }

        function saveColors() {
            const team = document.getElementById('teamSelect').value;
            if (!team) {
                alert("No team selected");
                return;
            }

            const pVal = document.getElementById('colPrimary').value;
            const tVal = document.getElementById('colText').value;

            const pRGB = hexToRgb(pVal);
            const tRGB = hexToRgb(tVal);

            if (!pRGB || !tRGB) {
                alert("Invalid color selection");
                return;
            }

            fetch('/api/colors', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    team: team,
                    primary: pRGB,
                    text: tRGB
                })
            })
                .then(r => r.json())
                .then(data => {
                    if (data.status === 'success') {
                        showStatus("Colors saved!", "lime");
                    } else {
                        alert("Error saving colors: " + data.message);
                    }
                })
                .catch(err => alert("Error: " + err));
        }

        function handleTeamChange() {
            loadColors();
            updateUI();
        }

        function showStatus(msg, color) {
            const div = document.getElementById('statusMsg');
            div.style.color = color || '#green';
            div.innerText = msg;
            setTimeout(() => { div.innerText = ''; }, 3000);
        }



        function parseLayoutCoord(def, dimensionSize) {
            if (Array.isArray(def)) {
                let base = def[0];
                let offset = def[1];
                let pixelBase = 0;
                if (typeof base === 'string' && base.includes('%')) {
                    const pct = parseFloat(base) / 100.0;
                    pixelBase = dimensionSize * pct;
                } else {
                    pixelBase = base;
                }
                return pixelBase + offset;
            } else if (typeof def === 'string' && def.includes('%')) {
                const pct = parseFloat(def) / 100.0;
                return dimensionSize * pct;
            } else {
                return def;
            }
        }

        function updateActualCoordinates() {
            const stance = document.getElementById('stanceSelect').value;
            const anchor = getAnchorPoint(stance);
            const offsetX = parseInt(document.getElementById('posX').value) || 0;
            const offsetY = parseInt(document.getElementById('posY').value) || 0;

            const absX = Math.round(anchor.x + offsetX);
            const absY = Math.round(anchor.y + offsetY);

            document.getElementById('absX').value = absX;
            document.getElementById('absY').value = absY;
        }

        // --- Core Logic ---

        function checkEmulatorStatus(isInit = false) {
            fetch('/api/emulator/status')
                .then(r => r.json())
                .then(data => {
                    emulatorRunning = data.running;
                    const dot = document.getElementById('emuStatusDot');
                    if (emulatorRunning) {
                        dot.classList.add('running');
                        if (isInit) {
                            const activeW = data.w;
                            const activeH = data.h;
                            const sizeStr = `${activeW}x${activeH}`;
                            const sel = document.getElementById('sizeSelect');
                            let found = false;
                            for (let i = 0; i < sel.options.length; i++) {
                                if (sel.options[i].value === sizeStr) {
                                    sel.selectedIndex = i;
                                    found = true;
                                    break;
                                }
                            }
                            matrixW = activeW;
                            matrixH = activeH;
                            loadMatrixSize(false);
                            const el = document.getElementById('emuWrapper');
                            el.classList.remove('collapsed');
                            const iframe = document.getElementById('emuFrame');
                            if (iframe.src === 'about:blank' || iframe.src === '') {
                                iframe.src = `http://localhost:{{ emulator_port }}`;
                            }
                        }
                    } else {
                        dot.classList.remove('running');
                        if (isInit) {
                            loadMatrixSize(false);
                        }
                    }
                });
        }

        let datePicker = null;

        function toggleEmulatorMode() {
            const mode = document.getElementById('emuMode').value;
            const simPanel = document.getElementById('simOptions');
            if (mode === 'simulator') {
                simPanel.style.display = 'flex';

                if (!datePicker) {
                    datePicker = flatpickr("#simDate", {
                        dateFormat: "Y-m-d",
                        maxDate: new Date().fp_incr(-1),
                        disable: [
                            function (date) {
                                // Disable all by default until loaded? 
                                // Better: enable specific dates. If enable array is empty, all disabled?
                                // If enable not set, all enabled.
                                // We want to highlight played games.
                                return false;
                            }
                        ],
                        onChange: function (selectedDates, dateStr, instance) {
                            simDateChanged();
                        },
                        onMonthChange: function (selectedDates, dateStr, instance) {
                            fetchMonthSchedule(instance.currentYear, instance.currentMonth + 1);
                        },
                        onOpen: function (selectedDates, dateStr, instance) {
                            // Fetch for current view if not loaded
                            fetchMonthSchedule(instance.currentYear, instance.currentMonth + 1);
                        }
                    });

                    // Initial fetch
                    const now = new Date();
                    fetchMonthSchedule(now.getFullYear(), now.getMonth() + 1);
                }

            } else {
                simPanel.style.display = 'none';
            }
            saveState();
        }

        // Cache for schedule data to avoid spamming API
        const scheduleCache = {};

        function fetchMonthSchedule(year, month) {
            const team = document.getElementById('teamSelect').value;
            if (!team) return;

            const monthStr = `${year}-${String(month).padStart(2, '0')}`;
            const cacheKey = `${team}_${monthStr}`;

            if (scheduleCache[cacheKey]) {
                updateDatePickerEnabled(scheduleCache[cacheKey]);
                return;
            }

            console.log(`Fetching schedule for ${team} in ${monthStr}`);
            fetch(`/api/schedule?team=${team}&month=${monthStr}`)
                .then(r => r.json())
                .then(data => {
                    if (data.games) {
                        scheduleCache[cacheKey] = data.games;
                        updateDatePickerEnabled(data.games);
                    }
                })
                .catch(e => console.error("Schedule fetch error", e));
        }

        function updateDatePickerEnabled(games) {
            if (!datePicker) return;

            // Extract dates for 'enable'
            const dates = games.map(g => g.date);

            // Map dates to types for easy lookup
            const gameTypes = {};
            games.forEach(g => {
                gameTypes[g.date] = g.type;
            });

            // Update configuration
            // We use onDayCreate to add classes
            datePicker.set('enable', dates);

            // We need to inject the gameTypes into the instance so onDayCreate can access it
            // independently of this closure if needed, or we just rely on redraw triggering onDayCreate
            // which we can hook now.

            // Flatpickr doesn't let us easily binding per-refresh data unless we just update the hook.
            // Let's update the onDayCreate hook dynamically? Or use a global/mapped variable.
            // Let's attach to the instance.
            datePicker.element.dataset.gameTypes = JSON.stringify(gameTypes);

            // Update the hook to read this
            datePicker.set("onDayCreate", function (dObj, dStr, fp, dayElem) {
                const dateStr = dayElem.dateObj.toISOString().split('T')[0];
                const types = JSON.parse(fp.element.dataset.gameTypes || "{}");

                if (types[dateStr]) {
                    if (types[dateStr] === 'home') {
                        dayElem.classList.add('home-game');
                    } else if (types[dateStr] === 'away') {
                        dayElem.classList.add('away-game');
                    }
                }
            });

            // Force redraw
            datePicker.redraw();
        }

        function simDateChanged() {
            const dateStr = document.getElementById('simDate').value;
            const team = document.getElementById('teamSelect').value;

            if (dateStr && team) {
                // Fetch opponent
                fetch(`/api/opponent?team=${team}&date=${dateStr}`)
                    .then(r => r.json())
                    .then(data => {
                        if (data.opponent) {
                            // Update Opponent for Visuals
                            const sel2 = document.getElementById('team2Select');
                            let found = false;
                            for (let i = 0; i < sel2.options.length; i++) {
                                if (sel2.options[i].value === data.opponent) {
                                    sel2.selectedIndex = i;
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) console.log("Opponent not found in list: " + data.opponent);

                            // Auto-Switch Stance
                            if (data.is_away) {
                                document.getElementById('stanceSelect').value = 'away';
                            } else {
                                document.getElementById('stanceSelect').value = 'home';
                            }

                            updateUI();
                        }
                    });
            }
            saveState();
        }

        // --- Persistence Logic ---
        function saveState() {
            const state = {
                size: document.getElementById('sizeSelect').value,
                team: document.getElementById('teamSelect').value,
                stance: document.getElementById('stanceSelect').value,

                // Simulator stuff
                emuMode: document.getElementById('emuMode').value,
                simDate: document.getElementById('simDate').value,
                simSpeed: document.getElementById('simSpeed').value,
                simStop: document.getElementById('simStopAtEnd').checked
            };
            localStorage.setItem('nhl_editor_state', JSON.stringify(state));
        }

        function loadState() {
            const saved = localStorage.getItem('nhl_editor_state');
            if (!saved) return;

            try {
                const state = JSON.parse(saved);

                // Matrix Size
                if (state.size) {
                    const sel = document.getElementById('sizeSelect');
                    if ([...sel.options].some(o => o.value === state.size)) {
                        sel.value = state.size;
                        // Don't trigger loadMatrixSize here, it's called by checkEmulatorStatus or manual call
                        // But we need to make sure global vars are set
                    }
                }

                // Team & Stance - restore after config loads
                if (state.team) window.restoreTeam = state.team;
                if (state.stance) window.restoreStance = state.stance;

                // Simulator options
                if (state.emuMode) {
                    const sel = document.getElementById('emuMode');
                    sel.value = state.emuMode;
                    toggleEmulatorMode();
                }
                if (state.simDate) document.getElementById('simDate').value = state.simDate;
                if (state.simSpeed) document.getElementById('simSpeed').value = state.simSpeed;
                if (state.simStop !== undefined) document.getElementById('simStopAtEnd').checked = state.simStop;

            } catch (e) {
                console.error("State restore error", e);
            }
        }

        function launchEmulator(target = 'iframe') {
            const status = document.getElementById('statusMsg');
            status.innerText = "Launching Emulator...";
            const loader = document.getElementById('emuLoader');
            const iframe = document.getElementById('emuFrame');
            const wrapper = document.getElementById('emuWrapper');
            const mode = document.getElementById('emuMode').value;

            if (target === 'iframe') {
                wrapper.classList.remove('collapsed');
                // Only show loader/iframe if intended (simulator might just be backend logs initially?)
                // But we assume simulator also renders to the same port, so we can view it.
                loader.style.display = 'flex';
                iframe.src = 'about:blank';
                // Show collapse button and reset text
                const btn = document.getElementById('btnCollapse');
                btn.style.display = 'inline-block';
                btn.innerText = 'Collapse';
            } else {
                window.open(`http://localhost:{{ emulator_port }}`, '_blank');
                // Hide collapse button if launching new window
                document.getElementById('btnCollapse').style.display = 'none';
            }

            const payload = { w: matrixW, h: matrixH, mode: mode };

            if (mode === 'simulator') {
                let teamVal = document.getElementById('teamSelect').value;
                // Strip suffix like "|alt" for the simulator backend
                if (teamVal.includes('|')) {
                    teamVal = teamVal.split('|')[0];
                }
                payload.team = teamVal;
                payload.date = document.getElementById('simDate').value;
                payload.speed = document.getElementById('simSpeed').value;
                payload.stop_at_end = document.getElementById('simStopAtEnd').checked;

                if (!payload.date) {
                    alert("Please select a date for simulation.");
                    status.innerText = "Error: Missing Date";
                    loader.style.display = 'none';
                    return;
                }
            }

            fetch('/api/emulator/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
                .then(r => r.json())
                .then(res => {
                    if (res.status === 'success') {
                        status.innerText = "Emulator Starting...";
                        status.style.color = "yellow";

                        // Poll for readiness
                        let attempts = 0;
                        const maxAttempts = 20; // 10 seconds (500ms * 20)

                        const checkReady = () => {
                            attempts++;
                            // Check if process died
                            fetch('/api/emulator/status').then(r => r.json()).then(pStatus => {
                                if (!pStatus.running) {
                                    // Process died
                                    fetchLogAndAlert();
                                    return;
                                }

                                fetch('/api/emulator/check_ready')
                                    .then(r => r.json())
                                    .then(data => {
                                        if (data.ready) {
                                            status.innerText = "Emulator Online!";
                                            status.style.color = "lightgreen";
                                            if (target === 'iframe') {
                                                iframe.src = `http://localhost:{{ emulator_port }}?t=${new Date().getTime()}`;
                                                iframe.onload = () => { loader.style.display = 'none'; };
                                                setTimeout(() => { loader.style.display = 'none'; }, 1000);
                                            }
                                            checkEmulatorStatus();
                                        } else {
                                            if (attempts < maxAttempts) {
                                                setTimeout(checkReady, 500);
                                            } else {
                                                status.innerText = "Error: Timeout waiting for emulator";
                                                status.style.color = "red";
                                                loader.style.display = 'none';
                                                fetchLogAndAlert();
                                            }
                                        }
                                    })
                                    .catch(e => {
                                        console.log("Readiness check error:", e);
                                        if (attempts < maxAttempts) setTimeout(checkReady, 500);
                                    });
                            });
                        };
                        checkReady();

                    } else {
                        status.innerText = "Error: " + res.message;
                        status.style.color = "red";
                        loader.style.display = 'none';
                    }
                });
        }

        function fetchLogAndAlert() {
            const loader = document.getElementById('emuLoader');
            const status = document.getElementById('statusMsg');
            loader.style.display = 'none';
            status.innerText = "Launch Failed";
            status.style.color = "red";

            fetch('/api/emulator/log')
                .then(r => r.json())
                .then(data => {
                    const log = data.log || "";
                    if (log.includes("404") || log.includes("Could not find game")) {
                        alert("Error: Game data not found (404).\n\nThe game might not have started yet, or no game exists for this date.");
                    } else if (log.includes("429") || log.includes("Too Many Requests")) {
                        alert("Error: API Throttling (429).\n\nPlease wait a moment before trying again.");
                    } else {
                        // Truncate log for alert
                        const shortLog = log.length > 500 ? "..." + log.slice(-500) : log;
                        alert("Emulator Failed to Start:\n\n" + shortLog);
                    }
                });
        }



        function stopEmulator() {
            fetch('/api/emulator/stop', { method: 'POST' })
                .then(r => r.json())
                .then(res => {
                    document.getElementById('statusMsg').innerText = "Emulator Stopped.";
                    document.getElementById('emuFrame').src = "about:blank";
                    checkEmulatorStatus();
                });
        }

        function toggleEmulatorCollapse() {
            const el = document.getElementById('emuWrapper');
            el.classList.toggle('collapsed');
            const btn = document.getElementById('btnCollapse');
            if (el.classList.contains('collapsed')) {
                btn.innerText = "Open";
            } else {
                btn.innerText = "Collapse";
            }
        }

        function loadMatrixSize(userTriggered = false) {
            const sizeStr = document.getElementById('sizeSelect').value;
            const [w, h] = sizeStr.split('x').map(Number);
            matrixW = w;
            matrixH = h;
            const pixelW = matrixW * EDITOR_SCALE;
            const pixelH = matrixH * EDITOR_SCALE;
            const canvas = document.getElementById('canvasContainer');
            canvas.style.width = pixelW + 'px';
            canvas.style.height = pixelH + 'px';
            canvas.style.backgroundSize = `${EDITOR_SCALE}px ${EDITOR_SCALE}px`;
            const inner = document.getElementById('emuInner');
            const emuW = matrixW * EMU_SCALE;
            const emuH = matrixH * EMU_SCALE;
            inner.style.width = emuW + 'px';
            inner.style.height = emuH + 'px';
            const emuWrap = document.getElementById('emuWrapper');
            emuWrap.style.width = (emuW + 20) + 'px';
            document.getElementById('resDisplay').innerText = `(${matrixW}x${matrixH})`;

            updateOverlayTextSizes();

            const gradImg = document.getElementById('gradientImg');
            const showGrad = document.getElementById('showGradient').checked;
            if (sizeStr === '64x32' || sizeStr === '128x64') {
                gradImg.src = `/assets/images/${sizeStr}_scoreboard_center_gradient.png`;
                gradImg.style.display = showGrad ? 'block' : 'none';
            } else {
                gradImg.style.display = 'none';
            }

            fetch(`/api/config/layout_${sizeStr}.json?t=${new Date().getTime()}`)
                .then(r => r.json())
                .then(layoutData => {
                    if (!layoutData || Object.keys(layoutData).length === 0) {
                        console.log(`Layout ${sizeStr} not found/empty. Falling back to layout.json.`);
                        return fetch('/api/config/layout.json').then(r => r.json());
                    }
                    return layoutData;
                })
                .then(layoutData => {
                    layoutConfig = layoutData;
                    const expectedFile = `logos_${sizeStr}.json`;
                    loadConfig(expectedFile);
                })
                .catch(err => {
                    console.error("Failed to load layout config", err);
                    layoutConfig = {};
                    loadConfig(`logos_${sizeStr}.json`);
                });

            if (userTriggered && emulatorRunning) {
                if (confirm(`Matrix size changed to ${sizeStr}. Restart the emulator with this resolution?`)) {
                    launchEmulator('iframe');
                }
            }
        }

        function toggleGradient() {
            const gradImg = document.getElementById('gradientImg');
            const showGrad = document.getElementById('showGradient').checked;
            const sizeStr = document.getElementById('sizeSelect').value;
            if (sizeStr === '64x32' || sizeStr === '128x64') {
                gradImg.style.display = showGrad ? 'block' : 'none';
            } else {
                gradImg.style.display = 'none';
            }
        }

        function updateOverlayTextSizes() {
            const sizeStr = document.getElementById('sizeSelect').value;
            let topLinesSize = 8;
            let scoreLineSize = 16;
            if (sizeStr === '128x64') {
                topLinesSize = 16;
                scoreLineSize = 32;
            }
            const cssTopSize = topLinesSize * EDITOR_SCALE;
            const cssScoreSize = scoreLineSize * EDITOR_SCALE;
            const lines = document.querySelectorAll('#gameInfoOverlay .info-line');
            lines[0].style.fontSize = cssTopSize + 'px';
            lines[0].style.height = cssTopSize + 'px';
            lines[1].style.fontSize = cssTopSize + 'px';
            lines[1].style.height = cssTopSize + 'px';
            lines[2].style.fontSize = cssScoreSize + 'px';
            lines[2].style.height = cssScoreSize + 'px';
        }



        function refreshTeamList() {
            const sel1 = document.getElementById('teamSelect');
            const sel2 = document.getElementById('team2Select');
            const cur1 = sel1.value;
            const cur2 = sel2.value;
            const options = [];
            STANDARD_TEAMS.forEach(t => options.push({ label: t, value: t }));
            if (currentConfig.scoreboard && currentConfig.scoreboard.logos) {
                const logos = currentConfig.scoreboard.logos;
                STANDARD_TEAMS.forEach(team => {
                    if (logos[team] && logos[team].alt) {
                        options.push({ label: `${team} (Alt)`, value: `${team}|alt` });
                    }
                });
                Object.keys(logos).forEach(k => {
                    if (k.startsWith('_')) return;
                    if (!STANDARD_TEAMS.includes(k) && !k.includes('|')) {
                        if (!options.find(o => o.value === k)) {
                            options.push({ label: k, value: k });
                        }
                    }
                });
            }
            options.sort((a, b) => a.label.localeCompare(b.label));
            sel1.innerHTML = '';
            sel2.innerHTML = '<option value="">(None)</option>';
            options.forEach(opt => {
                const el1 = document.createElement('option');
                el1.value = opt.value;
                el1.innerText = opt.label;
                sel1.appendChild(el1);
                const el2 = document.createElement('option');
                el2.value = opt.value;
                el2.innerText = opt.label;
                sel2.appendChild(el2);
            });
            if (cur1) sel1.value = cur1;
            if (cur2) sel2.value = cur2;
            if (sel1.selectedIndex === -1 && options.length > 0) sel1.selectedIndex = 0;
        }

        function getTeamConfig(team, stance) {
            if (!currentConfig.scoreboard || !currentConfig.scoreboard.logos) return {};
            let mainKey = team;
            let subKey = null;
            if (team.includes('|')) {
                const parts = team.split('|');
                mainKey = parts[0];
                subKey = parts[1];
            }
            const logos = currentConfig.scoreboard.logos;
            if (subKey) {
                if (logos[mainKey] && logos[mainKey][subKey]) {
                    const altObj = logos[mainKey][subKey];
                    if (altObj[stance]) return altObj[stance];
                    return altObj;
                }
                return null;
            }
            if (logos[mainKey]) {
                if (logos[mainKey][stance]) return logos[mainKey][stance];
                if (logos[mainKey].position) return logos[mainKey];
            }
            return null;
        }

        function updateUI() {
            saveState();

            // Refresh simulator calendar if valid
            if (window.datePicker && document.getElementById('emuMode').value === 'simulator') {
                // Convert from 0-index to 1-index
                fetchMonthSchedule(window.datePicker.currentYear, window.datePicker.currentMonth + 1);
            }

            const team1Val = document.getElementById('teamSelect').value;
            const stance1 = document.getElementById('stanceSelect').value;
            const team2Val = document.getElementById('team2Select').value;
            const sizeStr = document.getElementById('sizeSelect').value;

            // Update Tooltips
            if (team1Val) {
                const cleanName = team1Val.split('|')[0];
                document.getElementById('btnUploadFile').title = `Upload local file for ${cleanName}`;
                document.getElementById('btnUploadUrl').title = `Download Logo from URL for ${cleanName}`;
            }

            const getImageSrc = (val) => {
                if (!val) return '';
                let team = val;
                let type = 'light';
                if (val.includes('|')) {
                    const parts = val.split('|');
                    team = parts[0];
                    type = parts[1];
                }
                return `/assets/logos/${team}/${type}/${sizeStr}.png`;
            };

            const img1 = document.getElementById('logoImg');
            img1.src = getImageSrc(team1Val);

            let conf1 = getTeamConfig(team1Val, stance1);
            if (!conf1) conf1 = { position: [0, 0], zoom: "100%", rotate: 0, flip: 0 };
            let z = conf1.zoom || "100%";
            if (typeof z === 'string') z = parseInt(z.replace('%', ''));

            document.getElementById('posX').value = conf1.position ? conf1.position[0] : 0;
            document.getElementById('posY').value = conf1.position ? conf1.position[1] : 0;
            document.getElementById('zoom').value = z;
            document.getElementById('rotate').value = conf1.rotate || 0;
            img1.dataset.flip = conf1.flip || 0;

            const img2 = document.getElementById('logoImg2');
            if (team2Val) {
                img2.style.display = 'block';
                img2.src = getImageSrc(team2Val);

                // Forces opponent to use opposite stance
                const stance2 = (stance1 === 'home') ? 'away' : 'home';

                let rawOppConf = getTeamConfig(team2Val, stance2);
                if (!rawOppConf) rawOppConf = { position: [0, 0], zoom: "100%", rotate: 0, flip: 0 };
                opponentConfig = { ...rawOppConf };
                opponentConfig.stance = stance2;
            } else {
                img2.style.display = 'none';
                opponentConfig = null;
            }
            renderVisuals();
        }

        function getAnchorPoint(stance) {
            // Default to 50% +/- 15px logic which matches layout.json and layout_64x32.json
            const center = matrixW / 2;
            const offset = 15;
            let x = (stance === 'away') ? (center - offset) : (center + offset);
            let y = 0;
            // CORRECTED DEFAULTS: Away (Left side) -> Aligned Right (growing Left from center)
            let align = (stance === 'away') ? 'right' : 'left';

            if (layoutConfig && layoutConfig.scoreboard) {
                const key = (stance === 'home') ? 'home_logo' : 'away_logo';
                const logoConf = layoutConfig.scoreboard[key];
                if (logoConf) {
                    if (logoConf.position) {
                        const posDef = logoConf.position;
                        x = parseLayoutCoord(posDef[0], matrixW);
                        y = parseLayoutCoord(posDef[1], matrixH);
                    }
                    if (logoConf.align) {
                        align = logoConf.align;
                    }
                }
            }
            return { x: x, y: y, align: align };
        }

        function renderVisuals() {
            const stance1 = document.getElementById('stanceSelect').value;
            const img1 = document.getElementById('logoImg');
            const marker = document.getElementById('anchorMarker');

            const offsetX = parseInt(document.getElementById('posX').value);
            const offsetY = parseInt(document.getElementById('posY').value);
            const zoom = parseInt(document.getElementById('zoom').value) / 100;
            const rot = parseInt(document.getElementById('rotate').value);
            const flip = parseInt(img1.dataset.flip);

            const anchor1 = getAnchorPoint(stance1);

            const screenAnchorX = anchor1.x * EDITOR_SCALE;
            const screenAnchorY = anchor1.y * EDITOR_SCALE;

            marker.style.left = screenAnchorX + 'px';
            marker.style.top = screenAnchorY + 'px';

            const finalX = screenAnchorX + (offsetX * EDITOR_SCALE);
            const finalY = screenAnchorY + (offsetY * EDITOR_SCALE);

            applyTransform(img1, finalX, finalY, zoom, rot, flip, anchor1.align);

            if (opponentConfig) {
                const img2 = document.getElementById('logoImg2');
                const anchor2 = getAnchorPoint(opponentConfig.stance);

                let z2 = opponentConfig.zoom || "100%";
                if (typeof z2 === 'string') z2 = parseInt(z2.replace('%', ''));
                z2 = z2 / 100;

                const pos2 = opponentConfig.position || [0, 0];
                const finalX2 = (anchor2.x * EDITOR_SCALE) + (pos2[0] * EDITOR_SCALE);
                const finalY2 = (anchor2.y * EDITOR_SCALE) + (pos2[1] * EDITOR_SCALE);

                applyTransform(img2, finalX2, finalY2, z2, opponentConfig.rotate || 0, opponentConfig.flip || 0, anchor2.align);
            }

            updateActualCoordinates();
        }

        function applyTransform(img, x, y, zoom, rot, flip, align) {
            img.style.left = x + 'px';
            img.style.top = y + 'px';

            // Ensure proper origin logic
            img.style.transformOrigin = (align === 'right') ? 'top right' : 'top left';

            let alignTranslate = 'translate(0, 0)';
            if (align === 'right') alignTranslate = 'translate(-100%, 0)';
            if (align === 'center') alignTranslate = 'translate(-50%, 0)';

            const finalScale = zoom * EDITOR_SCALE;

            img.style.transform = `
            ${alignTranslate} 
            scale(${finalScale}) 
            rotate(${rot}deg) 
            ${flip ? 'scaleX(-1)' : ''}
        `;
        }

        function updateLogoFromInput() { renderVisuals(); }
        function toggleFlip() {
            const img = document.getElementById('logoImg');
            let f = parseInt(img.dataset.flip);
            f = f === 1 ? 0 : 1;
            img.dataset.flip = f;
            renderVisuals();
        }

        function resetDefaults() {
            const team = document.getElementById('teamSelect').value;
            const stance = document.getElementById('stanceSelect').value;
            let conf = getTeamConfig(team, stance);
            if (!conf) conf = { position: [0, 0], zoom: "100%", rotate: 0, flip: 0 };
            let z = conf.zoom || "100%";
            if (typeof z === 'string') z = parseInt(z.replace('%', ''));
            document.getElementById('posX').value = conf.position ? conf.position[0] : 0;
            document.getElementById('posY').value = conf.position ? conf.position[1] : 0;
            document.getElementById('zoom').value = z;
            document.getElementById('rotate').value = conf.rotate || 0;
            const img = document.getElementById('logoImg');
            img.dataset.flip = conf.flip || 0;
            renderVisuals();
        }

        function saveConfig() {
            const teamVal = document.getElementById('teamSelect').value;
            const stance = document.getElementById('stanceSelect').value;
            const filename = currentFileName;
            const status = document.getElementById('statusMsg');
            if (!filename) {
                status.innerText = "No file selected.";
                return;
            }
            const newObj = {
                zoom: document.getElementById('zoom').value + "%",
                position: [
                    parseInt(document.getElementById('posX').value),
                    parseInt(document.getElementById('posY').value)
                ],
                rotate: parseInt(document.getElementById('rotate').value),
                flip: parseInt(document.getElementById('logoImg').dataset.flip),
                crop: [0, 0, 0, 0]
            };
            if (!currentConfig.scoreboard) currentConfig.scoreboard = {};
            if (!currentConfig.scoreboard.logos) currentConfig.scoreboard.logos = {};
            let mainKey = teamVal;
            let subKey = null;
            if (teamVal.includes('|')) {
                const parts = teamVal.split('|');
                mainKey = parts[0];
                subKey = parts[1];
            }
            if (subKey) {
                if (!currentConfig.scoreboard.logos[mainKey]) currentConfig.scoreboard.logos[mainKey] = {};
                if (!currentConfig.scoreboard.logos[mainKey][subKey]) currentConfig.scoreboard.logos[mainKey][subKey] = {};
                currentConfig.scoreboard.logos[mainKey][subKey][stance] = newObj;
            } else {
                if (!currentConfig.scoreboard.logos[mainKey]) currentConfig.scoreboard.logos[mainKey] = {};
                currentConfig.scoreboard.logos[mainKey][stance] = newObj;
            }
            fetch('/api/config/' + filename, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(currentConfig)
            })
                .then(r => r.json())
                .then(res => {
                    if (res.status === 'success') {
                        status.innerText = "Saved!";
                        status.style.color = "#00ff00";
                    } else {
                        status.innerText = "Error: " + (res.message || "Unknown");
                        status.style.color = "#ff4444";
                    }
                    setTimeout(() => status.innerText = "", 3000);
                });
        }

        function setupDrag() {
            const img = document.getElementById('logoImg');
            let isDragging = false;
            let isResizing = false;
            let startX, startY;
            let startZoom = 100;

            window.addEventListener('keydown', e => {
                if (e.key === 'Shift') img.classList.add('resizing');
            });
            window.addEventListener('keyup', e => {
                if (e.key === 'Shift') img.classList.remove('resizing');
            });

            img.addEventListener('wheel', e => {
                e.preventDefault();
                let z = parseInt(document.getElementById('zoom').value) || 100;
                const delta = Math.sign(e.deltaY) * -5;
                let newZoom = z + delta;
                if (newZoom < 10) newZoom = 10;
                if (newZoom > 500) newZoom = 500;
                document.getElementById('zoom').value = newZoom;
                renderVisuals();
            });

            img.addEventListener('mousedown', e => {
                if (e.shiftKey) {
                    isResizing = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startZoom = parseInt(document.getElementById('zoom').value) || 100;
                    img.classList.add('resizing');
                    e.preventDefault();
                    e.stopPropagation();
                } else {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    img.style.cursor = 'grabbing';
                    e.preventDefault();
                }
            });

            window.addEventListener('mousemove', e => {
                if (isResizing) {
                    const dy = e.clientY - startY;
                    const dx = e.clientX - startX;
                    const delta = (Math.abs(dx) > Math.abs(dy)) ? dx : dy;
                    let newZoom = startZoom + delta;
                    if (newZoom < 10) newZoom = 10;
                    if (newZoom > 500) newZoom = 500;
                    document.getElementById('zoom').value = newZoom;
                    renderVisuals();
                    return;
                }

                if (!isDragging) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                const dMatrixX = Math.round(dx / EDITOR_SCALE);
                const dMatrixY = Math.round(dy / EDITOR_SCALE);

                if (dMatrixX !== 0 || dMatrixY !== 0) {
                    const xInput = document.getElementById('posX');
                    const yInput = document.getElementById('posY');
                    xInput.value = parseInt(xInput.value) + dMatrixX;
                    yInput.value = parseInt(yInput.value) + dMatrixY;
                    startX = e.clientX;
                    startY = e.clientY;
                    renderVisuals();
                }
            });

            window.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    if (!window.event || !window.event.shiftKey) img.classList.remove('resizing');
                }
                if (isDragging) {
                    isDragging = false;
                    img.style.cursor = 'move';
                }
            });
        }

    </script>
</body>

</html>